import * as classic from '@arbitrum/sdk-classic';
import * as nitro from '@arbitrum/sdk-nitro';
import { BigNumber, ContractTransaction, ethers, Overrides } from 'ethers';
import { TransactionReceipt } from '@ethersproject/providers';
import { GasOverrides as ClassicGasOverrides } from '@arbitrum/sdk-classic/dist/lib/message/L1ToL2MessageGasEstimator';
import { GasOverrides as NitroGasOverrides } from '@arbitrum/sdk-nitro/dist/lib/message/L1ToL2MessageGasEstimator';
import { Provider } from '@ethersproject/abstract-provider';
import { SignerOrProvider } from '../dataEntities/signerOrProvider';
import { L1ToL2MessageStatus, L1ToL2MessageWaitResult } from '../message/L1ToL2Message';
import { L2ToL1MessageStatus } from '../message/L2ToL1Message';
import { MessageDeliveredEvent as ClassicMessageDeliveredEvent } from '@arbitrum/sdk-classic/dist/lib/abi/Bridge';
import { FetchedEvent } from './eventFetcher';
import { InboxMessageDeliveredEvent as ClassicInboxMessageDeliveredEvent } from '@arbitrum/sdk-classic/dist/lib/abi/Inbox';
import { L1ToL2MessageReader as ClassicL1ToL2MessageReader } from '@arbitrum/sdk-classic/dist/index';
import { EthDepositParams, EthWithdrawParams } from '../assetBridger/ethBridger';
import { L2Network } from '../dataEntities/networks';
import { TokenDepositParams, TokenWithdrawParams } from '../assetBridger/erc20Bridger';
/**
 * New outboxes can be added to the bridge, and withdrawals always use the latest outbox.
 * This function finds the outbox address for a supplied batch number
 * @param network
 * @param batchNumber
 * @returns
 */
export declare const getOutboxAddr: (network: classic.L2Network, batchNumber: number) => string;
export declare const isNitroL1: (l2ChainId: number, l1Provider: SignerOrProvider, timeSinceCheckMs?: number) => Promise<boolean>;
export declare const isNitroL2: (l2SignerOrProvider: SignerOrProvider, timeSinceCheckMs?: number) => Promise<boolean>;
export declare const lookupExistingNetwork: (l2Network: nitro.L2Network) => classic.L2Network;
export declare const convertNetworkNitroToClassic: (l2Network: nitro.L2Network) => classic.L2Network;
export declare const convertNetworkClassicToNitro: (l2Network: classic.L2Network) => nitro.L2Network;
export declare const convertGasOverrides: (gasOverrides?: NitroGasOverrides) => Omit<ClassicGasOverrides, 'sendL2CallValueFromL1'>;
export declare const convertEstimates: (estimates: {
    maxGasBid: BigNumber;
    maxSubmissionPriceBid: BigNumber;
    maxGasPriceBid: BigNumber;
    totalDepositValue: BigNumber;
}) => {
    gasLimit: BigNumber;
    maxSubmissionFee: BigNumber;
    maxFeePerGas: BigNumber;
    totalL2GasCosts: BigNumber;
};
export declare const convertL2ToL1Status: (status: classic.L2ToL1MessageStatus) => nitro.L2ToL1MessageStatus;
export interface IL1ToL2MessageReader {
    readonly retryableCreationId: string;
    isExpired(): Promise<boolean>;
    status(): Promise<L1ToL2MessageStatus>;
    waitForStatus(confirmations?: number, timeout?: number): Promise<L1ToL2MessageWaitResult>;
    getTimeout(): Promise<BigNumber>;
    getBeneficiary(): Promise<string>;
    getInputs(): ReturnType<classic.L1ToL2MessageReader['getInputs']>;
}
export interface IL1ToL2MessageWriter extends IL1ToL2MessageReader {
    redeem(overrides?: Overrides): Promise<ContractTransaction>;
    cancel(overrides?: Overrides): Promise<ContractTransaction>;
}
export declare type IL1ToL2MessageReaderOrWriter<T extends SignerOrProvider> = T extends Provider ? IL1ToL2MessageReader : IL1ToL2MessageWriter;
export declare type IL2ToL1MessageReaderOrWriter<T extends SignerOrProvider> = T extends Provider ? IL2ToL1MessageReader : IL2ToL1MessageWriter;
export interface IL2ToL1MessageReader {
    getOutboxProof(l2Provider: Provider): Promise<MessageBatchProofInfo | null | string[]>;
    status(l2Provider: Provider): Promise<L2ToL1MessageStatus>;
    waitUntilReadyToExecute(l2Provider: Provider, retryDelay?: number): Promise<void>;
    getFirstExecutableBlock(l2Provider: Provider): Promise<BigNumber | null>;
}
export interface IL2ToL1MessageWriter extends IL2ToL1MessageReader {
    execute(l2Provider: Provider, overrides?: Overrides): Promise<ContractTransaction>;
}
export interface MessageBatchProofInfo {
    /**
     * Merkle proof of message inclusion in outbox entry
     */
    proof: string[];
    /**
     * Merkle path to message
     */
    path: BigNumber;
    /**
     * Sender of original message (i.e., caller of ArbSys.sendTxToL1)
     */
    l2Sender: string;
    /**
     * Destination address for L1 contract call
     */
    l1Dest: string;
    /**
     * L2 block number at which sendTxToL1 call was made
     */
    l2Block: BigNumber;
    /**
     * L1 block number at which sendTxToL1 call was made
     */
    l1Block: BigNumber;
    /**
     * L2 Timestamp at which sendTxToL1 call was made
     */
    timestamp: BigNumber;
    /**
     * Value in L1 message in wei
     */
    amount: BigNumber;
    /**
     * ABI-encoded L1 message data
     */
    calldataForL1: string;
}
export { ClassicMessageDeliveredEvent };
export declare type ClassicForceInclusionParams = FetchedEvent<ClassicMessageDeliveredEvent> & {
    delayedAcc: string;
};
/**
 * Nitro compatible EthDepositMessage
 */
export interface EthDepositMessage {
    readonly l2ChainId: number;
    readonly messageNumber: BigNumber;
    readonly to: string;
    readonly value: BigNumber;
    readonly l2DepositTxHash: string;
    wait(confirmations?: number, timeout?: number): Promise<ethers.providers.TransactionReceipt | null>;
}
export declare const toNitroEthDepositMessage: (message: ClassicL1ToL2MessageReader, l2ChainId: number, destinationAddress: string, l2CallValue: BigNumber) => Promise<EthDepositMessage>;
export declare const toClassicRetryableParams: (params: nitro.L1ToL2MessageReader['messageData']) => ReturnType<classic.L1ToL2MessageReader['getInputs']>;
/**
 * Temporary class for helping with x-chain message gas cost estimation.
 * Will be removed in nitro as this functionality will be available on the bridgers
 */
export declare class DepositWithdrawEstimator {
    readonly l2Network: L2Network;
    constructor(l2Network: L2Network);
    ethDepositL1Gas(params: EthDepositParams): Promise<BigNumber>;
    ethDepositL2Gas(l2Provider: Provider): Promise<{
        maxGas: BigNumber;
        maxSubmissionCost: BigNumber;
        maxGasPrice: BigNumber;
    }>;
    erc20Deposit20L1Gas(params: TokenDepositParams): Promise<BigNumber>;
    /**
     * Does the provided address look like a weth gateway
     * @param potentialWethGatewayAddress
     * @param l1Provider
     * @returns
     */
    private classiclooksLikeWethGateway;
    /**
     * Is this a known or unknown WETH gateway
     * @param gatewayAddress
     * @param l1Provider
     * @returns
     */
    private classicIsWethGateway;
    /**
     * Does the provided address look like a weth gateway
     * @param potentialWethGatewayAddress
     * @param l1Provider
     * @returns
     */
    private nitroLooksLikeWethGateway;
    /**
     * Is this a known or unknown WETH gateway
     * @param gatewayAddress
     * @param l1Provider
     * @returns
     */
    private nitroIsWethGateway;
    erc20DepositL2Gas(params: TokenDepositParams): Promise<{
        maxGas: BigNumber;
        maxSubmissionCost: BigNumber;
        maxGasPrice: BigNumber;
    }>;
    ethWithdrawalL1Gas(l2Provider: Provider): Promise<BigNumber>;
    ethWithdrawalL2Gas(params: EthWithdrawParams): Promise<BigNumber>;
    erc20WithdrawalL1Gas(l2Provider: Provider): Promise<BigNumber>;
    erc20WithdrawalL2Gas(params: TokenWithdrawParams): Promise<BigNumber>;
}
/**
 * Get any InboxMessageDelivered events that were emitted during this transaction
 * @returns
 */
export declare const classicGetInboxMessageDeliveredEvents: (receipt: TransactionReceipt) => ClassicInboxMessageDeliveredEvent['args'][];
