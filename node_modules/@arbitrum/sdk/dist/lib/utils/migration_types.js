"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.classicGetInboxMessageDeliveredEvents = exports.DepositWithdrawEstimator = exports.toClassicRetryableParams = exports.toNitroEthDepositMessage = exports.convertL2ToL1Status = exports.convertEstimates = exports.convertGasOverrides = exports.convertNetworkClassicToNitro = exports.convertNetworkNitroToClassic = exports.lookupExistingNetwork = exports.isNitroL2 = exports.isNitroL1 = exports.getOutboxAddr = void 0;
const classic = __importStar(require("@arbitrum/sdk-classic"));
const nitro = __importStar(require("@arbitrum/sdk-nitro"));
const ethers_1 = require("ethers");
const constants_1 = require("@ethersproject/constants");
const logger_1 = require("@ethersproject/logger");
const constants_2 = require("../dataEntities/constants");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const L1ERC20Gateway__factory_1 = require("@arbitrum/sdk-classic/dist/lib/abi/factories/L1ERC20Gateway__factory");
const L1WethGateway__factory_1 = require("@arbitrum/sdk-classic/dist/lib/abi/factories/L1WethGateway__factory");
const L1ERC20Gateway__factory_2 = require("@arbitrum/sdk-nitro/dist/lib/abi/factories/L1ERC20Gateway__factory");
const L1WethGateway__factory_2 = require("@arbitrum/sdk-nitro/dist/lib/abi/factories/L1WethGateway__factory");
const Inbox__factory_1 = require("@arbitrum/sdk-classic/dist/lib/abi/factories/Inbox__factory");
const networks_1 = require("@arbitrum/sdk-classic/dist/lib/dataEntities/networks");
const networks_2 = require("@arbitrum/sdk-nitro/dist/lib/dataEntities/networks");
const networks_3 = require("@arbitrum/sdk-classic/dist/lib/dataEntities/networks");
const networks_4 = require("@arbitrum/sdk-nitro/dist/lib/dataEntities/networks");
const lib_1 = require("@arbitrum/sdk-nitro/dist/lib/utils/lib");
const errors_1 = require("../dataEntities/errors");
const ethBridger_1 = require("../assetBridger/ethBridger");
const erc20Bridger_1 = require("../assetBridger/erc20Bridger");
/**
 * New outboxes can be added to the bridge, and withdrawals always use the latest outbox.
 * This function finds the outbox address for a supplied batch number
 * @param network
 * @param batchNumber
 * @returns
 */
const getOutboxAddr = (network, batchNumber) => {
    // find the outbox where the activation batch number of the next outbox
    // is greater than the supplied batch
    const res = Object.entries(network.ethBridge.outboxes)
        .sort((a, b) => {
        if (a[1].lt(b[1]))
            return -1;
        else if (a[1].eq(b[1]))
            return 0;
        else
            return 1;
    })
        .find((_, index, array) => array[index + 1] === undefined || array[index + 1][1].gt(batchNumber));
    if (!res) {
        throw new errors_1.ArbSdkError(`No outbox found for batch number: ${batchNumber} on network: ${network.chainID}.`);
    }
    return res[0];
};
exports.getOutboxAddr = getOutboxAddr;
const fifthteenMinutesMs = 15 * 60 * 1000;
const isNitroL1 = async (l2ChainId, l1Provider, 
/**
 * Wait at least this amount of time before rechecking if isNitro
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
timeSinceCheckMs = fifthteenMinutesMs) => {
    // everything is nitro now
    return true;
};
exports.isNitroL1 = isNitroL1;
const isNitroL2 = async (l2SignerOrProvider, 
/**
 * Wait at least this amount of time before rechecking if isNitro
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
timeSinceCheckMs = fifthteenMinutesMs) => {
    // everything is nitro now
    return true;
};
exports.isNitroL2 = isNitroL2;
const lookupExistingNetwork = (l2Network) => {
    const classicNetwork = networks_3.l2Networks[l2Network.chainID];
    if (!classicNetwork) {
        throw new errors_1.ArbSdkError(`Unexpected missing classic network for chain ${l2Network.chainID}`);
    }
    return classicNetwork;
};
exports.lookupExistingNetwork = lookupExistingNetwork;
const convertNetworkNitroToClassic = (l2Network) => {
    return Object.assign(Object.assign({}, l2Network), { ethBridge: Object.assign(Object.assign({}, l2Network.ethBridge), { outboxes: {
                [l2Network.ethBridge.outbox]: ethers_1.BigNumber.from(0),
            } }) });
};
exports.convertNetworkNitroToClassic = convertNetworkNitroToClassic;
const convertNetworkClassicToNitro = (l2Network) => {
    const outboxes = Object.keys(l2Network.ethBridge.outboxes);
    return Object.assign(Object.assign({}, l2Network), { ethBridge: Object.assign(Object.assign({}, l2Network.ethBridge), { outbox: outboxes[outboxes.length - 1] }), retryableLifetimeSeconds: constants_2.SEVEN_DAYS_IN_SECONDS, depositTimeout: l2Network.chainID === 421613 ? 3960000 : 888000 });
};
exports.convertNetworkClassicToNitro = convertNetworkClassicToNitro;
const convertGasOverrides = (gasOverrides) => {
    return {
        maxGas: gasOverrides === null || gasOverrides === void 0 ? void 0 : gasOverrides.gasLimit,
        maxSubmissionPrice: gasOverrides === null || gasOverrides === void 0 ? void 0 : gasOverrides.maxSubmissionFee,
        maxGasPrice: gasOverrides === null || gasOverrides === void 0 ? void 0 : gasOverrides.maxFeePerGas,
    };
};
exports.convertGasOverrides = convertGasOverrides;
const convertEstimates = (estimates) => {
    return {
        gasLimit: estimates.maxGasBid,
        maxSubmissionFee: estimates.maxSubmissionPriceBid,
        maxFeePerGas: estimates.maxGasPriceBid,
        totalL2GasCosts: estimates.maxGasPriceBid
            .mul(estimates.maxGasBid)
            .add(estimates.maxSubmissionPriceBid),
    };
};
exports.convertEstimates = convertEstimates;
const convertL2ToL1Status = (status) => {
    switch (status) {
        case classic.L2ToL1MessageStatus.CONFIRMED:
            return nitro.L2ToL1MessageStatus.CONFIRMED;
        case classic.L2ToL1MessageStatus.EXECUTED:
            return nitro.L2ToL1MessageStatus.EXECUTED;
        case classic.L2ToL1MessageStatus.NOT_FOUND:
            return nitro.L2ToL1MessageStatus.UNCONFIRMED;
        case classic.L2ToL1MessageStatus.UNCONFIRMED:
            return nitro.L2ToL1MessageStatus.UNCONFIRMED;
    }
};
exports.convertL2ToL1Status = convertL2ToL1Status;
const toNitroEthDepositMessage = async (message, l2ChainId, destinationAddress, l2CallValue) => {
    return {
        l2ChainId: l2ChainId,
        l2DepositTxHash: message.retryableCreationId,
        messageNumber: message.messageNumber,
        to: destinationAddress,
        value: l2CallValue,
        wait: async (confirmations, timeout) => {
            return ((await (0, lib_1.getTransactionReceipt)(message.l2Provider, message.retryableCreationId, confirmations, timeout)) || null);
        },
    };
};
exports.toNitroEthDepositMessage = toNitroEthDepositMessage;
const toClassicRetryableParams = async (params) => {
    if (params.data.length < 2 || params.data.length % 2 !== 0) {
        throw new errors_1.ArbSdkError(`Unxpected params data: ${params.data}.`);
    }
    return {
        callDataLength: ethers_1.BigNumber.from((params.data.startsWith('0x')
            ? params.data.length - 2
            : params.data.length) / 2),
        callValueRefundAddress: params.callValueRefundAddress,
        destinationAddress: params.destAddress,
        excessFeeRefundAddress: params.excessFeeRefundAddress,
        gasPriceBid: params.maxFeePerGas,
        l2CallValue: params.l2CallValue,
        maxGas: params.gasLimit,
        maxSubmissionCost: params.maxSubmissionFee,
    };
};
exports.toClassicRetryableParams = toClassicRetryableParams;
/**
 * Temporary class for helping with x-chain message gas cost estimation.
 * Will be removed in nitro as this functionality will be available on the bridgers
 */
class DepositWithdrawEstimator {
    constructor(l2Network) {
        this.l2Network = l2Network;
    }
    async ethDepositL1Gas(params) {
        const ethBridger = new ethBridger_1.EthBridger(this.l2Network);
        return await ethBridger.depositEstimateGas(params);
    }
    async ethDepositL2Gas(l2Provider) {
        if (await (0, exports.isNitroL2)(l2Provider)) {
            return {
                maxGas: ethers_1.BigNumber.from(0),
                maxSubmissionCost: ethers_1.BigNumber.from(0),
                maxGasPrice: ethers_1.BigNumber.from(0),
            };
        }
        else {
            const estimator = new classic.L1ToL2MessageGasEstimator(l2Provider);
            return {
                maxGas: ethers_1.BigNumber.from(0),
                maxSubmissionCost: (await estimator.estimateSubmissionPrice(0))
                    .submissionPrice,
                maxGasPrice: ethers_1.BigNumber.from(0),
            };
        }
    }
    async erc20Deposit20L1Gas(params) {
        const erc20Bridger = new erc20Bridger_1.Erc20Bridger(this.l2Network);
        return await erc20Bridger.depositEstimateGas(params);
    }
    /**
     * Does the provided address look like a weth gateway
     * @param potentialWethGatewayAddress
     * @param l1Provider
     * @returns
     */
    async classiclooksLikeWethGateway(potentialWethGatewayAddress, l1Provider) {
        try {
            const potentialWethGateway = L1WethGateway__factory_1.L1WethGateway__factory.connect(potentialWethGatewayAddress, l1Provider);
            await potentialWethGateway.callStatic.l1Weth();
            return true;
        }
        catch (err) {
            if (err instanceof Error &&
                err.code ===
                    logger_1.Logger.errors.CALL_EXCEPTION) {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Is this a known or unknown WETH gateway
     * @param gatewayAddress
     * @param l1Provider
     * @returns
     */
    async classicIsWethGateway(gatewayAddress, l1Provider) {
        const wethAddress = this.l2Network.tokenBridge.l1WethGateway;
        if (this.l2Network.isCustom) {
            // For custom network, we do an ad-hoc check to see if it's a WETH gateway
            if (await this.classiclooksLikeWethGateway(gatewayAddress, l1Provider)) {
                return true;
            }
            // ...otherwise we directly check it against the config file
        }
        else if (wethAddress === gatewayAddress) {
            return true;
        }
        return false;
    }
    /**
     * Does the provided address look like a weth gateway
     * @param potentialWethGatewayAddress
     * @param l1Provider
     * @returns
     */
    async nitroLooksLikeWethGateway(potentialWethGatewayAddress, l1Provider) {
        try {
            const potentialWethGateway = L1WethGateway__factory_2.L1WethGateway__factory.connect(potentialWethGatewayAddress, l1Provider);
            await potentialWethGateway.callStatic.l1Weth();
            return true;
        }
        catch (err) {
            if (err instanceof Error &&
                err.code ===
                    logger_1.Logger.errors.CALL_EXCEPTION) {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Is this a known or unknown WETH gateway
     * @param gatewayAddress
     * @param l1Provider
     * @returns
     */
    async nitroIsWethGateway(gatewayAddress, l1Provider) {
        const wethAddress = this.l2Network.tokenBridge.l1WethGateway;
        if (this.l2Network.isCustom) {
            // For custom network, we do an ad-hoc check to see if it's a WETH gateway
            if (await this.nitroLooksLikeWethGateway(gatewayAddress, l1Provider)) {
                return true;
            }
            // ...otherwise we directly check it against the config file
        }
        else if (wethAddress === gatewayAddress) {
            return true;
        }
        return false;
    }
    async erc20DepositL2Gas(params) {
        if (await (0, exports.isNitroL2)(params.l2Provider)) {
            const { erc20L1Address, amount, l2Provider, l1Signer, destinationAddress, } = params;
            const { retryableGasOverrides } = params;
            const erc20Bridger = new erc20Bridger_1.Erc20Bridger(this.l2Network);
            if (!signerOrProvider_1.SignerProviderUtils.signerHasProvider(l1Signer)) {
                throw new errors_1.MissingProviderArbTsError('l1Signer');
            }
            // 1. get the params for a gas estimate
            const l1GatewayAddress = await erc20Bridger.getL1GatewayAddress(erc20L1Address, l1Signer.provider);
            const l1Gateway = L1ERC20Gateway__factory_2.L1ERC20Gateway__factory.connect(l1GatewayAddress, l1Signer.provider);
            const sender = await l1Signer.getAddress();
            const to = destinationAddress ? destinationAddress : sender;
            const depositCalldata = await l1Gateway.getOutboundCalldata(erc20L1Address, sender, to, amount, '0x');
            // The WETH gateway is the only deposit that requires callvalue in the L2 user-tx (i.e., the recently un-wrapped ETH)
            // Here we check if this is a WETH deposit, and include the callvalue for the gas estimate query if so
            const isWeth = await this.nitroIsWethGateway(l1GatewayAddress, l1Signer.provider);
            const estimateGasCallValue = isWeth ? amount : constants_1.Zero;
            const l2Dest = await l1Gateway.counterpartGateway();
            const gasEstimator = new nitro.L1ToL2MessageGasEstimator(l2Provider);
            let tokenGasOverrides = retryableGasOverrides;
            // we also add a hardcoded minimum gas limit for custom gateway deposits
            if (l1GatewayAddress === this.l2Network.tokenBridge.l1CustomGateway) {
                if (!tokenGasOverrides)
                    tokenGasOverrides = {};
                if (!tokenGasOverrides.gasLimit)
                    tokenGasOverrides.gasLimit = {};
                if (!tokenGasOverrides.gasLimit.min) {
                    tokenGasOverrides.gasLimit.min =
                        erc20Bridger_1.Erc20Bridger.MIN_CUSTOM_DEPOSIT_GAS_LIMIT;
                }
            }
            // 2. get the gas estimates
            const baseFee = (await l1Signer.provider.getBlock('latest')).baseFeePerGas;
            if (!baseFee) {
                throw new errors_1.ArbSdkError('Latest block did not contain base fee, ensure provider is connected to a network that supports EIP 1559.');
            }
            const excessFeeRefundAddress = sender;
            const callValueRefundAddress = sender;
            const estimates = await gasEstimator.estimateAll(l1GatewayAddress, l2Dest, depositCalldata, estimateGasCallValue, baseFee, excessFeeRefundAddress, callValueRefundAddress, l1Signer.provider, tokenGasOverrides);
            return {
                maxGas: estimates.gasLimit,
                maxSubmissionCost: estimates.maxSubmissionFee,
                maxGasPrice: estimates.maxFeePerGas,
            };
        }
        else {
            const { erc20L1Address, amount, l2Provider, l1Signer, destinationAddress, } = params;
            const { retryableGasOverrides } = params;
            const erc20Bridger = new erc20Bridger_1.Erc20Bridger(this.l2Network);
            if (!signerOrProvider_1.SignerProviderUtils.signerHasProvider(l1Signer)) {
                throw new errors_1.MissingProviderArbTsError('l1Signer');
            }
            // 1. get the params for a gas estimate
            const l1GatewayAddress = await erc20Bridger.getL1GatewayAddress(erc20L1Address, l1Signer.provider);
            const l1Gateway = L1ERC20Gateway__factory_1.L1ERC20Gateway__factory.connect(l1GatewayAddress, l1Signer.provider);
            const sender = await l1Signer.getAddress();
            const to = destinationAddress ? destinationAddress : sender;
            const depositCalldata = await l1Gateway.getOutboundCalldata(erc20L1Address, sender, to, amount, '0x');
            // The WETH gateway is the only deposit that requires callvalue in the L2 user-tx (i.e., the recently un-wrapped ETH)
            // Here we check if this is a WETH deposit, and include the callvalue for the gas estimate query if so
            const estimateGasCallValue = (await this.classicIsWethGateway(l1GatewayAddress, l1Signer.provider))
                ? amount
                : constants_1.Zero;
            const l2Dest = await l1Gateway.counterpartGateway();
            const gasEstimator = new classic.L1ToL2MessageGasEstimator(l2Provider);
            let tokenGasOverrides = (0, exports.convertGasOverrides)(retryableGasOverrides);
            if (!tokenGasOverrides)
                tokenGasOverrides = {};
            // we never send l2 call value from l1 for tokens
            // since we check in the router that the value is submission cost
            // + gas price * gas
            tokenGasOverrides.sendL2CallValueFromL1 = false;
            // we also add a hardcoded minimum maxgas for custom gateway deposits
            if (l1GatewayAddress === this.l2Network.tokenBridge.l1CustomGateway) {
                if (!tokenGasOverrides.maxGas)
                    tokenGasOverrides.maxGas = {};
                tokenGasOverrides.maxGas.min =
                    classic.Erc20Bridger.MIN_CUSTOM_DEPOSIT_MAXGAS;
            }
            // 2. get the gas estimates
            const estimates = await gasEstimator.estimateMessage(l1GatewayAddress, l2Dest, depositCalldata, estimateGasCallValue, tokenGasOverrides);
            return {
                maxGas: estimates.maxGasBid,
                maxSubmissionCost: estimates.maxSubmissionPriceBid,
                maxGasPrice: estimates.maxGasPriceBid,
            };
        }
    }
    async ethWithdrawalL1Gas(l2Provider) {
        if (await (0, exports.isNitroL2)(l2Provider)) {
            //  measured 126998 - add some padding
            return ethers_1.BigNumber.from(130000);
        }
        else {
            // measured 161743 - add some padding
            return ethers_1.BigNumber.from(165000);
        }
    }
    async ethWithdrawalL2Gas(params) {
        const ethBridger = new ethBridger_1.EthBridger(this.l2Network);
        return await ethBridger.withdrawEstimateGas(params);
    }
    async erc20WithdrawalL1Gas(l2Provider) {
        if (await (0, exports.isNitroL2)(l2Provider)) {
            // measured 157421 - add some padding
            return ethers_1.BigNumber.from(160000);
        }
        else {
            // measured 218196 - added some padding
            return ethers_1.BigNumber.from(225000);
        }
    }
    async erc20WithdrawalL2Gas(params) {
        const ethBridger = new erc20Bridger_1.Erc20Bridger(this.l2Network);
        return await ethBridger.withdrawEstimateGas(params);
    }
}
exports.DepositWithdrawEstimator = DepositWithdrawEstimator;
/**
 * Get any InboxMessageDelivered events that were emitted during this transaction
 * @returns
 */
const classicGetInboxMessageDeliveredEvents = (receipt) => {
    const iFace = Inbox__factory_1.Inbox__factory.createInterface();
    const inboxMessageDeliveredTopic = iFace.getEventTopic(iFace.events['InboxMessageDelivered(uint256,bytes)']);
    return receipt.logs
        .filter(log => log.topics[0] === inboxMessageDeliveredTopic)
        .map(l => iFace.parseLog(l).args);
};
exports.classicGetInboxMessageDeliveredEvents = classicGetInboxMessageDeliveredEvents;
// patch networks to be consistent
networks_1.l1Networks[1].partnerChainIDs.push(42170);
networks_1.l1Networks[5] = networks_2.l1Networks[5];
networks_3.l2Networks[421613] = (0, exports.convertNetworkNitroToClassic)(networks_4.l2Networks[421613]);
networks_3.l2Networks[42170] = (0, exports.convertNetworkNitroToClassic)(networks_4.l2Networks[42170]);
