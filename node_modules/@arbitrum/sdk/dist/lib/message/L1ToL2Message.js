/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1ToL2MessageWriter = exports.L1ToL2MessageReader = exports.L1ToL2Message = exports.L1ToL2MessageStatus = exports.L2TxnType = void 0;
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const errors_1 = require("../dataEntities/errors");
const classic = __importStar(require("@arbitrum/sdk-classic"));
const nitro = __importStar(require("@arbitrum/sdk-nitro"));
const migration_types_1 = require("../utils/migration_types");
const lib_1 = require("@arbitrum/sdk-nitro/dist/lib/utils/lib");
var L2TxnType;
(function (L2TxnType) {
    L2TxnType[L2TxnType["L2_TX"] = 0] = "L2_TX";
    L2TxnType[L2TxnType["AUTO_REDEEM"] = 1] = "AUTO_REDEEM";
})(L2TxnType = exports.L2TxnType || (exports.L2TxnType = {}));
var L1ToL2MessageStatus;
(function (L1ToL2MessageStatus) {
    /**
     * The retryable ticket has yet to be created
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["NOT_YET_CREATED"] = 1] = "NOT_YET_CREATED";
    /**
     * An attempt was made to create the retryable ticket, but it failed.
     * This could be due to not enough submission cost being paid by the L1 transaction
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["CREATION_FAILED"] = 2] = "CREATION_FAILED";
    /**
     * The retryable ticket has been created but has not been redeemed. This could be due to the
     * auto redeem failing, or if the params (max l2 gas price) * (max l2 gas) = 0 then no auto
     * redeem tx is ever issued. An auto redeem is also never issued for ETH deposits.
     * A manual redeem is now required.
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["FUNDS_DEPOSITED_ON_L2"] = 3] = "FUNDS_DEPOSITED_ON_L2";
    /**
     * The retryable ticket has been redeemed (either by auto, or manually) and the
     * l2 transaction has been executed
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["REDEEMED"] = 4] = "REDEEMED";
    /**
     * The message has either expired or has been canceled. It can no longer be redeemed.
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["EXPIRED"] = 5] = "EXPIRED";
})(L1ToL2MessageStatus = exports.L1ToL2MessageStatus || (exports.L1ToL2MessageStatus = {}));
class L1ToL2Message {
    static fromClassic(readerOrWriter) {
        if (readerOrWriter.l2Signer) {
            return L1ToL2MessageWriter.fromClassic(readerOrWriter);
        }
        else {
            return L1ToL2MessageReader.fromClassic(readerOrWriter);
        }
    }
    static fromNitro(readerOrWriter) {
        if (readerOrWriter.l2Signer) {
            return L1ToL2MessageWriter.fromNitro(readerOrWriter);
        }
        else {
            return L1ToL2MessageReader.fromNitro(readerOrWriter);
        }
    }
    static fromTxComponents(l2SignerOrProvider, chainId, sender, messageNumber, l1BaseFee, messageData) {
        return signerOrProvider_1.SignerProviderUtils.isSigner(l2SignerOrProvider)
            ? new L1ToL2MessageWriter(l2SignerOrProvider, chainId, sender, messageNumber, l1BaseFee, messageData)
            : new L1ToL2MessageReader(l2SignerOrProvider, chainId, sender, messageNumber, l1BaseFee, messageData);
    }
}
exports.L1ToL2Message = L1ToL2Message;
class SwivelledReader extends nitro.L1ToL2MessageReader {
    constructor(l2Provider, chainId, sender, messageNumber, l1BaseFee, messageData, retryableCreationId, l2TxHash) {
        super(l2Provider, chainId, sender, messageNumber, l1BaseFee, messageData, l2TxHash);
        this.classicRetryableReceipt = null;
        this.classicRetryableId = retryableCreationId;
    }
    async getRetryableCreationReceipt(confirmations, timeout) {
        if (!this.classicRetryableId)
            return await super.getRetryableCreationReceipt();
        if (!this.classicRetryableReceipt) {
            this.classicRetryableReceipt = await (0, lib_1.getTransactionReceipt)(this.l2Provider, this.classicRetryableId, confirmations, timeout);
        }
        return this.classicRetryableReceipt || null;
    }
}
class SwivelledWriter extends nitro.L1ToL2MessageWriter {
    constructor(l2Signer, chainId, sender, messageNumber, l1BaseFee, messageData, retryableCreationId, l2TxHash) {
        super(l2Signer, chainId, sender, messageNumber, l1BaseFee, messageData, l2TxHash);
        this.classicRetryableReceipt = null;
        this.classicRetryableId = retryableCreationId;
    }
    async getRetryableCreationReceipt(confirmations, timeout) {
        if (!this.classicRetryableId)
            return await super.getRetryableCreationReceipt();
        if (!this.classicRetryableReceipt) {
            this.classicRetryableReceipt = await (0, lib_1.getTransactionReceipt)(this.l2Provider, this.classicRetryableId, confirmations, timeout);
        }
        return this.classicRetryableReceipt || null;
    }
}
class L1ToL2MessageReader extends L1ToL2Message {
    constructor(l2Provider, chainId, sender, messageNumber, l1BaseFee, messageData, retryableCreationId) {
        super();
        this.l2Provider = l2Provider;
        if (retryableCreationId && messageNumber) {
            this.classicReader = new classic.L1ToL2MessageReader(l2Provider, retryableCreationId, messageNumber);
            this.classicPartnerReader = new SwivelledReader(l2Provider, chainId, // although these can be empty we know that they wont be used by the nitro reader
            sender, messageNumber, l1BaseFee, messageData, this.classicReader.retryableCreationId, this.classicReader.l2TxHash);
            this.retryableCreationId = retryableCreationId;
        }
        else if (chainId && sender && messageNumber && l1BaseFee && messageData) {
            this.nitroReader = new nitro.L1ToL2MessageReader(l2Provider, chainId, sender, messageNumber, l1BaseFee, messageData);
            this.retryableCreationId = this.nitroReader.retryableCreationId;
        }
        else {
            throw new errors_1.ArbSdkError('Unexpected L1ToL2MessageReader constructor args');
        }
    }
    static fromClassic(classicReader) {
        return new L1ToL2MessageReader(classicReader.l2Provider, undefined, undefined, classicReader.messageNumber, undefined, undefined, classicReader.retryableCreationId);
    }
    static fromNitro(nitroReader) {
        return new L1ToL2MessageReader(nitroReader.l2Provider, nitroReader.chainId, nitroReader.sender, nitroReader.messageNumber, nitroReader.l1BaseFee, nitroReader.messageData, undefined);
    }
    /**
     * Has this message expired. Once expired the retryable ticket can no longer be redeemed.
     * @returns
     */
    async isExpired() {
        if (this.nitroReader) {
            return await this.nitroReader.isExpired();
        }
        else if (await (0, migration_types_1.isNitroL2)(this.l2Provider)) {
            return await this.classicPartnerReader.isExpired();
        }
        else {
            return await this.classicReader.isExpired();
        }
    }
    async status() {
        if (this.nitroReader) {
            return await this.nitroReader.status();
        }
        else if (await (0, migration_types_1.isNitroL2)(this.l2Provider)) {
            return await this.classicPartnerReader.status();
        }
        else {
            return await this.classicReader.status();
        }
    }
    /**
     * Get and format inputs provided in calldata for retryable messsage (message type 9)
     */
    async getInputs() {
        return this.nitroReader
            ? (0, migration_types_1.toClassicRetryableParams)(this.nitroReader.messageData)
            : await this.classicReader.getInputs();
    }
    /**
     * Wait for the retryable ticket to be created, for it to be redeemed, and for the l2Tx to be executed.
     * Note: The terminal status of a transaction that only does an eth deposit is FUNDS_DEPOSITED_ON_L2 as
     * no L2 transaction needs to be executed, however the terminal state of any other transaction is REDEEMED
     * which represents that the retryable ticket has been redeemed and the L2 tx has been executed.
     * @param confirmations Amount of confirmations the retryable ticket and the auto redeem receipt should have
     * @param timeout Amount of time to wait for the retryable ticket to be created
     * Defaults to 15 minutes, as by this time all transactions are expected to be included on L2. Throws on timeout.
     * @returns The wait result contains a status, and optionally the l2TxReceipt.
     * If the status is "REDEEMED" then a l2TxReceipt is also available on the result.
     * If the status has any other value then l2TxReceipt is not populated.
     */
    async waitForStatus(confirmations, timeout = 900000) {
        if (this.nitroReader) {
            return await this.nitroReader.waitForStatus(confirmations, timeout);
        }
        else if (await (0, migration_types_1.isNitroL2)(this.l2Provider)) {
            return await this.classicPartnerReader.waitForStatus(confirmations, timeout);
        }
        else {
            return await this.classicReader.waitForStatus(confirmations, timeout);
        }
    }
    /**
     * How long until this message expires
     * @returns
     */
    async getTimeout() {
        if (this.nitroReader) {
            return await this.nitroReader.getTimeout();
        }
        else if (await (0, migration_types_1.isNitroL2)(this.l2Provider)) {
            return await this.classicPartnerReader.getTimeout();
        }
        else {
            return await this.classicReader.getTimeout();
        }
    }
    /**
     * Address to which CallValue will be credited to on L2 if the retryable ticket times out or is cancelled.
     * The Beneficiary is also the address with the right to cancel a Retryable Ticket (if the ticket hasn’t been redeemed yet).
     * @returns
     */
    async getBeneficiary() {
        if (this.nitroReader) {
            return await this.nitroReader.getBeneficiary();
        }
        else if (await (0, migration_types_1.isNitroL2)(this.l2Provider)) {
            return await this.classicPartnerReader.getBeneficiary();
        }
        else {
            return await this.classicReader.getBeneficiary();
        }
    }
}
exports.L1ToL2MessageReader = L1ToL2MessageReader;
class L1ToL2MessageWriter extends L1ToL2MessageReader {
    constructor(l2Signer, chainId, sender, messageNumber, l1BaseFee, messageData, retryableCreationId) {
        super(l2Signer.provider, chainId, sender, messageNumber, l1BaseFee, messageData, retryableCreationId);
        this.l2Signer = l2Signer;
        if (!l2Signer.provider)
            throw new Error('Signer not connected to provider.');
        // super(chainId, sender, messageNumber, l1BaseFee, messageData)
        if (retryableCreationId && messageNumber) {
            this.classicWriter = new classic.L1ToL2MessageWriter(l2Signer, retryableCreationId, messageNumber);
            this.classicPartnerWriter = new SwivelledWriter(l2Signer, chainId, sender, messageNumber, l1BaseFee, messageData, this.classicWriter.retryableCreationId, this.classicWriter.l2TxHash);
        }
        else if (chainId && sender && messageNumber && l1BaseFee && messageData) {
            this.nitroWriter = new nitro.L1ToL2MessageWriter(l2Signer, chainId, sender, messageNumber, l1BaseFee, messageData);
        }
        else {
            throw new errors_1.ArbSdkError('Unexpected L1ToL2MessageWriter constructor args');
        }
    }
    static fromClassic(classicWriter) {
        return new L1ToL2MessageWriter(classicWriter.l2Signer, undefined, undefined, classicWriter.messageNumber, undefined, undefined, classicWriter.retryableCreationId);
    }
    static fromNitro(nitroWriter) {
        return new L1ToL2MessageWriter(nitroWriter.l2Signer, nitroWriter.chainId, nitroWriter.sender, nitroWriter.messageNumber, nitroWriter.l1BaseFee, nitroWriter.messageData, undefined);
    }
    /**
     * Manually redeem the retryable ticket.
     * Throws if message status is not L1ToL2MessageStatus.NOT_YET_REDEEMED
     */
    async redeem(overrides) {
        if (this.nitroWriter) {
            return await this.nitroWriter.redeem(overrides);
        }
        else if (await (0, migration_types_1.isNitroL2)(this.l2Provider)) {
            return await this.classicPartnerWriter.redeem(overrides);
        }
        else {
            return await this.classicWriter.redeem();
        }
    }
    /**
     * Cancel the retryable ticket.
     * Throws if message status is not L1ToL2MessageStatus.NOT_YET_REDEEMED
     */
    async cancel(overrides) {
        if (this.nitroWriter) {
            return await this.nitroWriter.cancel(overrides);
        }
        else if (await (0, migration_types_1.isNitroL2)(this.l2Provider)) {
            return await this.classicPartnerWriter.cancel(overrides);
        }
        else {
            return await this.classicWriter.cancel();
        }
    }
}
exports.L1ToL2MessageWriter = L1ToL2MessageWriter;
