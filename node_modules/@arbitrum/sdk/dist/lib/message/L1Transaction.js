/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1ContractCallTransactionReceipt = exports.L1EthDepositTransactionReceipt = exports.L1TransactionReceipt = void 0;
const L1ToL2Message_1 = require("./L1ToL2Message");
const L1ERC20Gateway__factory_1 = require("../abi/factories/L1ERC20Gateway__factory");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const classic = __importStar(require("@arbitrum/sdk-classic"));
const nitro = __importStar(require("@arbitrum/sdk-nitro"));
const L1Transaction_1 = require("@arbitrum/sdk-nitro/dist/lib/message/L1Transaction");
const L1Transaction_2 = require("@arbitrum/sdk-classic/dist/lib/message/L1Transaction");
const migration_types_1 = require("../utils/migration_types");
const errors_1 = require("../dataEntities/errors");
const messageDataParser_1 = require("./messageDataParser");
class L1TransactionReceipt {
    constructor(tx) {
        this.to = tx.to;
        this.from = tx.from;
        this.contractAddress = tx.contractAddress;
        this.transactionIndex = tx.transactionIndex;
        this.root = tx.root;
        this.gasUsed = tx.gasUsed;
        this.logsBloom = tx.logsBloom;
        this.blockHash = tx.blockHash;
        this.transactionHash = tx.transactionHash;
        this.logs = tx.logs;
        this.blockNumber = tx.blockNumber;
        this.confirmations = tx.confirmations;
        this.cumulativeGasUsed = tx.cumulativeGasUsed;
        this.effectiveGasPrice = tx.effectiveGasPrice;
        this.byzantium = tx.byzantium;
        this.type = tx.type;
        this.status = tx.status;
        this.classicReceipt = new classic.L1TransactionReceipt(tx);
        this.nitroReceipt = new nitro.L1TransactionReceipt(tx);
    }
    async looksLikeEthDeposit(gasLimit, gasPrice, callDataLength) {
        return gasLimit.eq(0) && gasPrice.eq(0) && callDataLength === 0;
    }
    /**
     * Classic and nitro message events have different signatures. This means that if this tx
     * has a classic event, it cant have had a nitro one
     * @returns
     */
    hasClassicMessages() {
        return this.classicReceipt.getMessages().length > 0;
    }
    /**
     * Get any eth deposit messages created by this transaction
     * @param l2SignerOrProvider
     */
    async getEthDepositMessages(l2SignerOrProvider) {
        if (!this.hasClassicMessages()) {
            return this.nitroReceipt.getEthDepositMessages(signerOrProvider_1.SignerProviderUtils.getProviderOrThrow(l2SignerOrProvider));
        }
        else {
            // get all the l1tol2messages that are eth deposits
            const l1ToL2Messages = await this.classicReceipt.getL1ToL2Messages(l2SignerOrProvider);
            const inboxMessageDeliveredEvents = (0, migration_types_1.classicGetInboxMessageDeliveredEvents)(this);
            const pairings = l1ToL2Messages
                .map(m => {
                const pairedEvent = inboxMessageDeliveredEvents.filter(i => i.messageNum.eq(m.messageNumber))[0];
                if (!pairedEvent)
                    return undefined;
                const retryableMessageParser = new messageDataParser_1.SubmitRetryableMessageDataParser();
                const parsedEvent = retryableMessageParser.parse(pairedEvent.data);
                return {
                    message: m,
                    inboxEvent: parsedEvent,
                };
            })
                .filter(i => i != undefined)
                .map(i => i);
            const typedMessages = await Promise.all(pairings.map(async (l) => ({
                isEthDeposit: await this.looksLikeEthDeposit(l.inboxEvent.gasLimit, l.inboxEvent.maxFeePerGas, l.inboxEvent.data.length - 2),
                eventData: l.inboxEvent,
                message: l.message,
            })));
            const chainId = (await signerOrProvider_1.SignerProviderUtils.getProviderOrThrow(l2SignerOrProvider).getNetwork()).chainId;
            return Promise.all(typedMessages
                .filter(t => t.isEthDeposit)
                .map(async (t) => await (0, migration_types_1.toNitroEthDepositMessage)(t.message, chainId, t.eventData.destAddress, t.eventData.l2CallValue)));
        }
    }
    async getL1ToL2Messages(l2SignerOrProvider) {
        if (!this.hasClassicMessages()) {
            return (await this.nitroReceipt.getL1ToL2Messages(l2SignerOrProvider)).map(r => L1ToL2Message_1.L1ToL2Message.fromNitro(r));
        }
        else {
            // get all the l1tol2messages that are not eth deposits
            const l1ToL2Messages = await this.classicReceipt.getL1ToL2Messages(l2SignerOrProvider);
            const inboxMessageDeliveredEvents = (0, migration_types_1.classicGetInboxMessageDeliveredEvents)(this);
            const pairings = l1ToL2Messages
                .map(m => {
                const pairedEvent = inboxMessageDeliveredEvents.filter(i => i.messageNum.eq(m.messageNumber))[0];
                if (!pairedEvent)
                    return undefined;
                const retryableMessageParser = new messageDataParser_1.SubmitRetryableMessageDataParser();
                const parsedEvent = retryableMessageParser.parse(pairedEvent.data);
                return {
                    message: m,
                    inboxEvent: parsedEvent,
                };
            })
                .filter(i => i != undefined)
                .map(i => i);
            const typedMessages = await Promise.all(pairings.map(async (l) => ({
                isEthDeposit: await this.looksLikeEthDeposit(l.inboxEvent.gasLimit, l.inboxEvent.maxFeePerGas, l.inboxEvent.data.length - 2),
                message: l.message,
            })));
            const classicL1ToL2Messages = await Promise.all(typedMessages.filter(t => !t.isEthDeposit).map(t => t.message));
            return classicL1ToL2Messages.map(c => L1ToL2Message_1.L1ToL2Message.fromClassic(c));
        }
    }
    async getL1ToL2Message(l2SignerOrProvider, messageIndex) {
        const messages = await this.getL1ToL2Messages(l2SignerOrProvider);
        if (messages.length > 1 && messageIndex == undefined)
            throw new errors_1.ArbSdkError(`More than one message found, but no message index supplied: ${messages.length} ${this.transactionHash}`);
        const message = messages[messageIndex || 0];
        if (message == undefined)
            throw new errors_1.ArbSdkError(`No message found for index: ${messageIndex || 0} ${this.transactionHash}`);
        return message;
    }
    /**
     * Get any token deposit events created by this transaction
     * @returns
     */
    getTokenDepositEvents() {
        const iface = L1ERC20Gateway__factory_1.L1ERC20Gateway__factory.createInterface();
        const event = iface.getEvent('DepositInitiated');
        const eventTopic = iface.getEventTopic(event);
        const logs = this.logs.filter(log => log.topics[0] === eventTopic);
        return logs.map(log => iface.parseLog(log).args);
    }
}
exports.L1TransactionReceipt = L1TransactionReceipt;
_a = L1TransactionReceipt;
/**
 * Replaces the wait function with one that returns an L1TransactionReceipt
 * @param contractTransaction
 * @returns
 */
L1TransactionReceipt.monkeyPatchWait = (contractTransaction) => {
    const wait = contractTransaction.wait;
    contractTransaction.wait = async (confirmations) => {
        const result = await wait(confirmations);
        return new L1TransactionReceipt(result);
    };
    return contractTransaction;
};
/**
 * Replaces the wait function with one that returns an L1EthDepositTransactionReceipt
 * @param contractTransaction
 * @returns
 */
L1TransactionReceipt.monkeyPatchEthDepositWait = (contractTransaction) => {
    const wait = contractTransaction.wait;
    contractTransaction.wait = async (confirmations) => {
        const result = await wait(confirmations);
        return new L1EthDepositTransactionReceipt(result);
    };
    return contractTransaction;
};
/**
 * Replaces the wait function with one that returns an L1ContractCallTransactionReceipt
 * @param contractTransaction
 * @returns
 */
L1TransactionReceipt.monkeyPatchContractCallWait = (contractTransaction) => {
    const wait = contractTransaction.wait;
    contractTransaction.wait = async (confirmations) => {
        const result = await wait(confirmations);
        return new L1ContractCallTransactionReceipt(result);
    };
    return contractTransaction;
};
/**
 * An L1TransactionReceipt with additional functionality that only exists
 * if the transaction created a single eth deposit.
 */
class L1EthDepositTransactionReceipt extends L1TransactionReceipt {
    /**
     * Wait for the funds to arrive on L2
     * @param confirmations Amount of confirmations the retryable ticket and the auto redeem receipt should have
     * @param timeout Amount of time to wait for the retryable ticket to be created
     * Defaults to 15 minutes, as by this time all transactions are expected to be included on L2. Throws on timeout.
     * @returns The wait result contains `complete`, a `status`, the L1ToL2Message and optionally the `l2TxReceipt`
     * If `complete` is true then this message is in the terminal state.
     * For eth deposits complete this is when the status is FUNDS_DEPOSITED, EXPIRED or REDEEMED.
     */
    async waitForL2(l2Provider, confirmations, timeout = 900000) {
        if (!this.hasClassicMessages()) {
            const receipt = new L1Transaction_1.L1EthDepositTransactionReceipt(this);
            return await receipt.waitForL2(l2Provider, confirmations, timeout);
        }
        else {
            const receipt = new L1Transaction_2.L1EthDepositTransactionReceipt(this);
            const classicWaitRes = await receipt.waitForL2(l2Provider, confirmations, timeout);
            const inputs = await classicWaitRes.message.getInputs();
            const ethDepositMessage = await (0, migration_types_1.toNitroEthDepositMessage)(classicWaitRes.message, (await l2Provider.getNetwork()).chainId, inputs.destinationAddress, inputs.l2CallValue);
            const txReceipt = await ethDepositMessage.wait();
            return {
                message: ethDepositMessage,
                complete: classicWaitRes.complete,
                l2TxReceipt: txReceipt,
            };
        }
    }
}
exports.L1EthDepositTransactionReceipt = L1EthDepositTransactionReceipt;
/**
 * An L1TransactionReceipt with additional functionality that only exists
 * if the transaction created a single call to an L2 contract - this includes
 * token deposits.
 */
class L1ContractCallTransactionReceipt extends L1TransactionReceipt {
    /**
     * Wait for the transaction to arrive and be executed on L2
     * @param confirmations Amount of confirmations the retryable ticket and the auto redeem receipt should have
     * @param timeout Amount of time to wait for the retryable ticket to be created
     * Defaults to 15 minutes, as by this time all transactions are expected to be included on L2. Throws on timeout.
     * @returns The wait result contains `complete`, a `status`, an L1ToL2Message and optionally the `l2TxReceipt`.
     * If `complete` is true then this message is in the terminal state.
     * For contract calls this is true only if the status is REDEEMED.
     */
    async waitForL2(l2SignerOrProvider, confirmations, timeout = 900000) {
        const message = (await this.getL1ToL2Messages(l2SignerOrProvider))[0];
        const res = await message.waitForStatus(confirmations, timeout);
        return Object.assign(Object.assign({ complete: res.status === L1ToL2Message_1.L1ToL2MessageStatus.REDEEMED }, res), { message });
    }
}
exports.L1ContractCallTransactionReceipt = L1ContractCallTransactionReceipt;
