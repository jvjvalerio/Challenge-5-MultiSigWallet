{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/untitled/meta-multi-sig-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/Users/untitled/meta-multi-sig-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/untitled/meta-multi-sig-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/untitled/meta-multi-sig-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar baseX$1 = require('../../vendor/base-x.js');\n\nvar bytes = require('../bytes.js');\n\nvar Encoder = /*#__PURE__*/function () {\n  function Encoder(name, prefix, baseEncode) {\n    _classCallCheck(this, Encoder);\n\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n\n  _createClass(Encoder, [{\n    key: \"encode\",\n    value: function encode(bytes) {\n      if (bytes instanceof Uint8Array) {\n        return \"\".concat(this.prefix).concat(this.baseEncode(bytes));\n      } else {\n        throw Error('Unknown type, must be binary type');\n      }\n    }\n  }]);\n\n  return Encoder;\n}();\n\nvar Decoder = /*#__PURE__*/function () {\n  function Decoder(name, prefix, baseDecode) {\n    _classCallCheck(this, Decoder);\n\n    this.name = name;\n    this.prefix = prefix;\n\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n\n  _createClass(Decoder, [{\n    key: \"decode\",\n    value: function decode(text) {\n      if (typeof text === 'string') {\n        if (text.codePointAt(0) !== this.prefixCodePoint) {\n          throw Error(\"Unable to decode multibase string \".concat(JSON.stringify(text), \", \").concat(this.name, \" decoder only supports inputs prefixed with \").concat(this.prefix));\n        }\n\n        return this.baseDecode(text.slice(this.prefix.length));\n      } else {\n        throw Error('Can only multibase decode strings');\n      }\n    }\n  }, {\n    key: \"or\",\n    value: function or(decoder) {\n      return _or(this, decoder);\n    }\n  }]);\n\n  return Decoder;\n}();\n\nvar ComposedDecoder = /*#__PURE__*/function () {\n  function ComposedDecoder(decoders) {\n    _classCallCheck(this, ComposedDecoder);\n\n    this.decoders = decoders;\n  }\n\n  _createClass(ComposedDecoder, [{\n    key: \"or\",\n    value: function or(decoder) {\n      return _or(this, decoder);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(input) {\n      var prefix = input[0];\n      var decoder = this.decoders[prefix];\n\n      if (decoder) {\n        return decoder.decode(input);\n      } else {\n        throw RangeError(\"Unable to decode multibase string \".concat(JSON.stringify(input), \", only inputs prefixed with \").concat(Object.keys(this.decoders), \" are supported\"));\n      }\n    }\n  }]);\n\n  return ComposedDecoder;\n}();\n\nvar _or = function _or(left, right) {\n  return new ComposedDecoder(_objectSpread(_objectSpread({}, left.decoders || _defineProperty({}, left.prefix, left)), right.decoders || _defineProperty({}, right.prefix, right)));\n};\n\nvar Codec = /*#__PURE__*/function () {\n  function Codec(name, prefix, baseEncode, baseDecode) {\n    _classCallCheck(this, Codec);\n\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n\n  _createClass(Codec, [{\n    key: \"encode\",\n    value: function encode(input) {\n      return this.encoder.encode(input);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(input) {\n      return this.decoder.decode(input);\n    }\n  }]);\n\n  return Codec;\n}();\n\nvar from = function from(_ref3) {\n  var name = _ref3.name,\n      prefix = _ref3.prefix,\n      encode = _ref3.encode,\n      decode = _ref3.decode;\n  return new Codec(name, prefix, encode, decode);\n};\n\nvar baseX = function baseX(_ref4) {\n  var prefix = _ref4.prefix,\n      name = _ref4.name,\n      alphabet = _ref4.alphabet;\n\n  var _baseX$ = baseX$1(alphabet, name),\n      encode = _baseX$.encode,\n      _decode = _baseX$.decode;\n\n  return from({\n    prefix: prefix,\n    name: name,\n    encode: encode,\n    decode: function decode(text) {\n      return bytes.coerce(_decode(text));\n    }\n  });\n};\n\nvar _decode2 = function decode(string, alphabet, bitsPerChar, name) {\n  var codes = {};\n\n  for (var i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n\n  var end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end;\n  }\n\n  var out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  var bits = 0;\n  var buffer = 0;\n  var written = 0;\n\n  for (var _i = 0; _i < end; ++_i) {\n    var value = codes[string[_i]];\n\n    if (value === undefined) {\n      throw new SyntaxError(\"Non-\".concat(name, \" character\"));\n    }\n\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n};\n\nvar _encode = function encode(data, alphabet, bitsPerChar) {\n  var pad = alphabet[alphabet.length - 1] === '=';\n  var mask = (1 << bitsPerChar) - 1;\n  var out = '';\n  var bits = 0;\n  var buffer = 0;\n\n  for (var i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n};\n\nvar rfc4648 = function rfc4648(_ref5) {\n  var name = _ref5.name,\n      prefix = _ref5.prefix,\n      bitsPerChar = _ref5.bitsPerChar,\n      alphabet = _ref5.alphabet;\n  return from({\n    prefix: prefix,\n    name: name,\n    encode: function encode(input) {\n      return _encode(input, alphabet, bitsPerChar);\n    },\n    decode: function decode(input) {\n      return _decode2(input, alphabet, bitsPerChar, name);\n    }\n  });\n};\n\nexports.Codec = Codec;\nexports.baseX = baseX;\nexports.from = from;\nexports.or = _or;\nexports.rfc4648 = rfc4648;","map":{"version":3,"sources":["/Users/untitled/meta-multi-sig-v2/node_modules/multiformats/cjs/src/bases/base.js"],"names":["Object","defineProperty","exports","value","baseX$1","require","bytes","Encoder","name","prefix","baseEncode","Uint8Array","Error","Decoder","baseDecode","codePointAt","undefined","prefixCodePoint","text","JSON","stringify","slice","length","decoder","or","ComposedDecoder","decoders","input","decode","RangeError","keys","left","right","Codec","encoder","encode","from","baseX","alphabet","coerce","string","bitsPerChar","codes","i","end","out","bits","buffer","written","SyntaxError","data","pad","mask","rfc4648"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar baseX$1 = require('../../vendor/base-x.js');\nvar bytes = require('../bytes.js');\n\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nconst or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nclass Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nconst from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nconst baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = baseX$1(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => bytes.coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nconst rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};\n\nexports.Codec = Codec;\nexports.baseX = baseX;\nexports.from = from;\nexports.or = or;\nexports.rfc4648 = rfc4648;\n"]},"metadata":{},"sourceType":"script"}